"""
File housing all report code.
"""
import numpy as np


######## Synthetic reports (generated by gpt-4) ########

def success_rate(observation, action, next_observation, memory):
    """
    Computes the success rate of picking up the box over a trajectory.
    """
    description = "Success rate of picking up the box"
    result = 1.0 if observation['inv'] == [7] else 0.0
    return {"result": result, "description": description}

def key_pickup_success(observation, action, next_observation, memory):
    if 'key_pickup_attempts' not in memory:
        memory['key_pickup_attempts'] = 0
        memory['key_pickups'] = 0
    if observation['agent']['image'][3][5][0] == 5 and action == 3:  # If facing a key and action is to pick up
        memory['key_pickup_attempts'] += 1
        if 5 in next_observation['inv']:  # If next observation has key in inventory
            memory['key_pickups'] += 1
    if memory['key_pickup_attempts'] > 0:
        success_rate = memory['key_pickups'] / memory['key_pickup_attempts']
    else:
        success_rate = 0.0
    return {"result": success_rate, "description": "Key pickup success rate"}

def door_interaction_efficiency(observation, action, next_observation, memory):
    if 'door_interactions' not in memory:
        memory['door_interactions'] = 0
        memory['successful_door_opens'] = 0
    if observation['agent']['image'][3][5][0] == 4 and action == 5:  # If facing a door and action is to toggle
        memory['door_interactions'] += 1
        if next_observation['agent']['image'][3][5][2] == 0:  # If next observation shows door is open
            memory['successful_door_opens'] += 1
    if memory['door_interactions'] > 0:
        efficiency = memory['successful_door_opens'] / memory['door_interactions']
    else:
        efficiency = 0.0
    return {"result": efficiency, "description": "Door interaction efficiency"}

def exploration_efficiency(observation, action, next_observation, memory):
    if 'moves' not in memory:
        memory['moves'] = 0
        memory['new_tiles_explored'] = 0
        memory['explored_tiles'] = set()
    memory['moves'] += 1
    forward_tile = tuple(observation['agent']['image'][3][5])
    if action == 2 and forward_tile not in memory['explored_tiles']:  # If the action is to move forward and the tile is new
        memory['new_tiles_explored'] += 1
        memory['explored_tiles'].add(forward_tile)
    if memory['moves'] > 0:
        efficiency = memory['new_tiles_explored'] / memory['moves']
    else:
        efficiency = 0.0
    return {"result": efficiency, "description": "Exploration efficiency"}

def report_box_pickup_attempts(observation, action, next_observation, memory):
    """
    Tracks the number of times the policy attempted to pick up the box.
    """
    if "box_pickup_attempts" not in memory:
        memory["box_pickup_attempts"] = 0
    if action == 3 and observation['agent']['image'][3][5][0] == 7:  # If action is pickup and facing a box
        memory["box_pickup_attempts"] += 1
    memory["description"] = "Number of attempts made to pick up the box."
    memory["result"] = memory.get("box_pickup_attempts", 0)
    return memory


def report_steps_before_box_pickup(observation, action, next_observation, memory):
    """
    Calculates the number of steps taken before the first box pickup attempt.
    """
    if "first_box_pickup_step" not in memory:
        memory["first_box_pickup_step"] = -1
        memory["steps"] = 0
    memory["steps"] += 1
    if action == 3 and observation['agent']['image'][3][5][0] == 7 and memory["first_box_pickup_step"] == -1:  # If action is pickup and facing a box
        memory["first_box_pickup_step"] = memory["steps"]
    memory["description"] = "Average number of steps taken before the first attempt to pick up the box."
    memory["result"] = memory.get("first_box_pickup_step", 0)
    return memory


def report_distance_traveled_before_box_pickup(observation, action, next_observation, memory):
    """
    Calculates the distance traveled before attempting to pick up the box.
    """
    if "distance_traveled" not in memory:
        memory["distance_traveled"] = 0
        memory["attempted_box_pickup"] = False
    if action == 2:  # If action is move forward
        memory["distance_traveled"] += 1
    if action == 3 and observation['agent']['image'][3][5][0] == 7:  # If action is pickup and facing a box
        memory["attempted_box_pickup"] = True
    memory["description"] = "Distance traveled before attempting to pick up the box."
    if memory["attempted_box_pickup"]:
        memory["result"] = memory.get("distance_traveled", 0)
    else:
        memory["result"] = 0
    return memory


def report_efficiency_of_movement(observation, action, next_observation, memory):
    """
    Calculates the ratio of successful movements to total movements.
    """
    if "successful_moves" not in memory:
        memory["successful_moves"] = 0
        memory["total_moves"] = 0
    if action == 2:  # If action is move forward
        memory["total_moves"] += 1
        if next_observation['agent']['image'][3][6][0] not in [2, 4, 9]:  # If next tile is not a wall, door, or lava
            memory["successful_moves"] += 1
    memory["description"] = "Efficiency of movement."
    if memory["total_moves"] > 0:
        memory["result"] = memory["successful_moves"] / memory["total_moves"]
    else:
        memory["result"] = 0
    return memory

def report_inventory_management(observation, action, next_observation, memory):
    if 'inventory_full_when_box_seen' not in memory:
        memory['inventory_full_when_box_seen'] = 0
        memory['box_encounters'] = 0
        memory['description'] = "Percentage of times the inventory was full when the box was encountered."

    # Check if the box is in the observation and the inventory is full
    if observation['agent']['image'][3][5][0] == 7 and len(observation['inv']) > 0:
        memory['inventory_full_when_box_seen'] += 1
    if observation['agent']['image'][3][5][0] == 7:
        memory['box_encounters'] += 1

    # Compute final result at the end of trajectory
    if memory['box_encounters'] > 0:
        memory['result'] = {"inventory_full_when_box_seen": memory['inventory_full_when_box_seen'], "box_encounters": memory['box_encounters']}
    else:
        memory['result'] = 0  # No box encounters
    
    return memory

def report_objective_prioritization(observation, action, next_observation, memory):
    if 'moves_towards_box' not in memory:
        memory['moves_towards_box'] = 0
        memory['box_seen'] = 0
        memory['description'] = "Percentage of agent's actions that move towards the box when it is visible."

    # Check if the box is visible and the action is to move forward
    if observation['agent']['image'][3][5][0] == 7 and action == 2:
        memory['moves_towards_box'] += 1
    if observation['agent']['image'][3][5][0] == 7:
        memory['box_seen'] += 1

    # Compute final result at the end of trajectory
    memory['result'] = {"moves_toward_box": memory['moves_towards_box'], "box_seen": memory['box_seen']}
    
    return memory

def report_box_recognition_and_action(observation, action, next_observation, memory):
    if 'box_pickup_attempts' not in memory:
        memory['box_pickup_attempts'] = 0
        memory['box_seen'] = 0
        memory['description'] = "Percentage of agent's actions that attempt to pick up the box when it is directly in front."

    # Check if the box is directly in front and the action is to pick up
    if observation['agent']['image'][3][5][0] == 7 and action == 3:
        memory['box_pickup_attempts'] += 1
    if observation['agent']['image'][3][5][0] == 7:
        memory['box_seen'] += 1

    # Compute final result at the end of trajectory
    if memory['box_seen'] > 0:
        memory['result'] = {"box_pickup_attempts": memory['box_pickup_attempts'], "box_seen": memory['box_seen']}
    else:
        memory['result'] = 0  # No box seen
    
    return memory

def report_inventory_and_key_management(observation, action, next_observation, memory):
    if 'description' not in memory:
        memory['description'] = "Tracks key and box management, including if the key is dropped prematurely and if the box is picked up efficiently."
        memory['key_picked_up'] = False
        memory['key_dropped_before_box'] = False
        memory['box_picked_up_with_key'] = False
        memory['box_encountered'] = False

    # Check if the key is picked up
    if action == 3 and observation['agent']['image'][3, 5, 0] == 5:
        memory['key_picked_up'] = True

    # Check if the box is encountered
    if observation['agent']['image'][3, 5, 0] == 7:
        memory['box_encountered'] = True
        # Check if the agent attempts to pick up the box
        if action == 3:
            memory['box_picked_up_with_key'] = memory['key_picked_up'] and not memory['key_dropped_before_box']

    # Check if the key is dropped before picking up the box
    if action == 4 and memory['key_picked_up'] and not memory['box_encountered']:
        memory['key_dropped_before_box'] = True

    if len(observation['inv']) == 0 and memory['key_picked_up']:
        # Inventory is empty, could be after dropping the key
        memory['key_picked_up'] = False

    # At the end of the trajectory, determine if the box was picked up directly after encountering it without unnecessary key drops
    if 'result' not in memory:
        memory['result'] = {
            'key_dropped_before_box': float(memory['key_dropped_before_box']),
            'box_picked_up_with_key': float(memory['box_picked_up_with_key']),
        }

    return memory

def report_exploration_efficiency(observation, action, next_observation, memory):
    if 'description' not in memory:
        memory['description'] = "Assesses the agent's exploration efficiency after unlocking a door, focusing on movements and actions that lead towards the box."
        memory['door_unlocked'] = False
        memory['steps_after_unlock'] = 0
        memory['steps_towards_box'] = 0

    if action == 5 and observation['agent']['image'][3, 5, 2] == 2:  # Action to unlock door
        memory['door_unlocked'] = True

    if memory['door_unlocked']:
        memory['steps_after_unlock'] += 1
        if next_observation['agent']['image'][:, :, 0].any() == 7:  # If box is visible in the observation
            memory['steps_towards_box'] += 1

    if 'result' not in memory:
        memory['result'] = {
            'steps_towards_box': memory['steps_towards_box'],
            'steps_after_unlock': memory['steps_after_unlock']
        }

    return memory

def report_inventory_management_strategy(observation, action, next_observation, memory):
    if 'description' not in memory:
        memory['description'] = "Tracks inventory changes and evaluates the agent's strategy in managing inventory relative to mission-critical objects. It counts both pickups and drops separately."
        memory['item_picked_up'] = 0
        memory['item_dropped'] = 0

    if action == 3:  # Pickup action
        memory['item_picked_up'] += 1
    elif action == 4:  # Drop action
        memory['item_dropped'] += 1

    if 'result' not in memory:
        memory['result'] = {
            'items_picked_up': memory['item_picked_up'],
            'items_dropped': memory['item_dropped']
        }

    return memory

def report_action_sequencing(observation, action, next_observation, memory):
    if 'description' not in memory:
        memory['description'] = "Analyzes the sequence of actions taken by the agent post-door-unlocking, emphasizing actions that directly contribute to achieving the goal. Reports the count of each action type."
        memory['door_unlocked'] = False
        memory['actions_post_unlock'] = []

    if action == 5 and observation['agent']['image'][3, 5, 2] == 2:  # Door unlock action
        memory['door_unlocked'] = True

    if memory['door_unlocked']:
        memory['actions_post_unlock'].append(action)

    if 'result' not in memory:
        memory['result'] = {
            'total_actions_post_unlock': len(memory['actions_post_unlock']),
            'action_distribution': {str(act): memory['actions_post_unlock'].count(act) for act in set(memory['actions_post_unlock'])}
        }

    return memory

def report_drop_action_efficiency(observation, action, next_observation, memory: dict) -> dict:
    if "drop_attempts" not in memory:
        memory["drop_attempts"] = 0  # Total number of drop actions attempted
        memory["successful_drops"] = 0  # Drops that resulted in item being removed from inventory
        memory["unnecessary_drops"] = 0  # Drops that didn't change inventory state (possibly no item to drop)
        memory["description"] = ("This report analyzes the efficiency of the drop action by counting how many times the agent "
                                  "attempts to drop an item, how many of those attempts were necessary (the agent was actually "
                                  "holding an item), and how many were unnecessary (no item to drop). "
                                  "Efficiency is evaluated based on whether each drop action leads to a meaningful progress "
                                  "towards task completion.")

    # Check if the current action is a drop action
    if action == 4:
        memory["drop_attempts"] += 1
        if observation['inv'] and not next_observation['inv']:
            # If the agent was holding an item before the action and is not holding it afterward
            memory["successful_drops"] += 1
        else:
            # If the inventory state doesn't change before and after the action
            memory["unnecessary_drops"] += 1

    # After the last timestep in a trajectory, calculate the efficiency metrics
    total_drops = memory["drop_attempts"]
    successful_drops = memory["successful_drops"]
    unnecessary_drops = memory["unnecessary_drops"]
    if total_drops > 0:
        drop_efficiency = successful_drops / total_drops
        unnecessary_drop_rate = unnecessary_drops / total_drops
    else:
        drop_efficiency = 1  # Default to 1 (100%) if no drops were attempted, indicating no inefficiency
        unnecessary_drop_rate = 0
    
    memory["result"] = {
        "total_drop_attempts": total_drops,
        "drop_efficiency": drop_efficiency,
        "unnecessary_drop_rate": unnecessary_drop_rate
    }

    return memory

def report_action_post_box_visibility(observation, action, next_observation, memory):
    """
    Tracks the immediate actions taken by the agent after the box becomes visible.
    This aims to highlight whether the agent prioritizes moving towards the box or engages in other activities.
    """
    # Initialize memory if it's the first call
    if 'box_seen_actions' not in memory:
        memory['box_seen_actions'] = []
        memory['box_seen'] = False
    
    # Check if the box is visible in the current observation
    box_visible = np.any(observation['agent']['image'][:, :, 0] == 7)
    
    if box_visible:
        memory['box_seen'] = True
        memory['box_seen_actions'].append(action)  # Log action taken when box is visible
    
    if memory['box_seen'] and not box_visible:
        # Reset the flag if the box was seen but is not visible in the current step
        memory['box_seen'] = False

    # Finalize the report
    if 'description' not in memory:
        memory['description'] = "Tracks the immediate actions taken by the agent after the box becomes visible."
        
    # Final result
    if 'result' not in memory:
        # Calculate the distribution or average of actions taken post-box visibility
        memory['result'] = {action: memory['box_seen_actions'].count(action) / len(memory['box_seen_actions']) for action in set(memory['box_seen_actions'])} if memory['box_seen_actions'] else {}

    return memory

def ItemManagementEfficiency(observation, action, next_observation, memory):
    # Initialize memory structure if first call
    if "initialized" not in memory:
        memory["initialized"] = True
        memory["drop_actions"] = 0
        memory["unnecessary_drops"] = 0
        memory["key_pickups"] = 0
        memory["successful_door_unlocks"] = 0
        memory["box_pickups"] = 0
        memory["final_step"] = False  # This will be set to True externally at the end of the trajectory
    
    # Increment counters based on action and outcome
    current_tile = observation['agent']['image'][3][6]
    forward_tile = observation['agent']['image'][3][5]
    inv = observation['inv']

    # Track key pickup
    if action == 3 and forward_tile[0] == 5:  # Pickup key action
        memory["key_pickups"] += 1
    
    # Track door unlock success
    if action == 5 and forward_tile[0] == 4:  # Unlock door action
        memory["successful_door_unlocks"] += 1
    
    # Track box pickup
    if action == 3 and forward_tile[0] == 7:  # Pickup box action
        memory["box_pickups"] += 1
    
    # Track drop actions
    if action == 4:  # Drop item action
        memory["drop_actions"] += 1
        # Check if drop was unnecessary
        if (forward_tile[0] != 7 or 'box' not in inv) and not (forward_tile[0] == 4 and forward_tile[2] == 2):  # Conditions where dropping is unnecessary
            memory["unnecessary_drops"] += 1

    if memory["final_step"]:  # Finalize report at the end of trajectory
        total_actions = memory["drop_actions"] + memory["key_pickups"] + memory["successful_door_unlocks"] + memory["box_pickups"]
        drop_efficiency = (memory["drop_actions"] - memory["unnecessary_drops"]) / memory["drop_actions"] if memory["drop_actions"] > 0 else 0
        memory["result"] = {
            "drop_efficiency": drop_efficiency,
            "unnecessary_drop_ratio": memory["unnecessary_drops"] / total_actions if total_actions > 0 else 0,
            "key_usage_efficiency": memory["successful_door_unlocks"] / memory["key_pickups"] if memory["key_pickups"] > 0 else 0,
            "task_completion_efficiency": memory["box_pickups"] / 1  # Since the goal is to pick up the box
        }
        memory["description"] = "Evaluates the efficiency of item management, including key pickups, door unlocks, and the necessity and efficiency of 'drop item' actions."
    
    return memory


synthetic_reports = {
    "success_rate": success_rate,
    "key_pickup_success": key_pickup_success,
    "door_interaction_efficiency": door_interaction_efficiency,
    "exploration_efficiency": exploration_efficiency,
    "report_box_pickup_attempts": report_box_pickup_attempts,
    "report_steps_before_box_pickup": report_steps_before_box_pickup,
    "report_distance_traveled_before_box_pickup": report_distance_traveled_before_box_pickup,
    "report_efficiency_of_movement": report_efficiency_of_movement,
    "report_inventory_management": report_inventory_management,
    "report_objective_prioritization": report_objective_prioritization,
    "report_box_recognition_and_action": report_box_recognition_and_action,
    "report_exploration_efficiency": report_exploration_efficiency,
    "report_inventory_management_strategy": report_inventory_management_strategy,
    "report_action_sequencing": report_action_sequencing,
    "report_inventory_and_key_management": report_inventory_and_key_management,
    "report_drop_action_efficiency": report_drop_action_efficiency,
    "report_action_post_box_visibility": report_action_post_box_visibility,
    "ItemManagementEfficiency": ItemManagementEfficiency,
}