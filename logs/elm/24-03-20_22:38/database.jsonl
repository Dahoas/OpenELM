{"src": "import numpy as np\n\nclass Policy:\n    def __init__(self):\n        self.memory = {}\n        self.notes = []\n\n    def act(self, observation):\n        direction = observation['direction']\n        tiles = observation['image']\n\n        # Check if there's a key visible in the tile and we are facing it\n        if tiles[3][5][0] == 5 and self.can_pickup(tiles, direction):\n            self.notes.append('Picked up key')\n            return 3  # Pickup action\n\n        # Check if there's a locked door visible in the tile and we are facing it with a key\n        if tiles[3][5][0] == 4 and tiles[3][5][2] == 2 and self.can_toggle_key(tiles, direction):\n            self.notes.append('Opened door with key')\n            return 5  # Toggle key action\n\n        # Move forward if the front tile is empty\n        if tiles[3][5][0] == 1:\n            return 2  # Move forward\n\n        # Turn left if the front tile is not empty\n        return 0  # Turn left\n\n    def update(self, observation, action, reward, next_observation):\n        pass\n\n    def can_pickup(self, tiles, direction):\n        if direction == 0 and tiles[3][6][0] == 5:  # Facing right\n            return True\n        elif direction == 1 and tiles[4][5][0] == 5:  # Facing down\n            return True\n        elif direction == 2 and tiles[3][4][0] == 5:  # Facing left\n            return True\n        elif direction == 3 and tiles[2][5][0] == 5:  # Facing up\n            return True\n        else:\n            return False\n\n    def can_toggle_key(self, tiles, direction):\n        if direction == 0 and tiles[3][6][0] == 4:  # Facing right\n            return True\n        elif direction == 1 and tiles[4][5][0] == 4:  # Facing down\n            return True\n        elif direction == 2 and tiles[3][4][0] == 4:  # Facing left\n            return True\n        elif direction == 3 and tiles[2][5][0] == 4:  # Facing up\n            return True\n        else:\n            return False\n\n    def produce_report(self):\n        return f\"Policy action notes: {', '.join(self.notes)}\"\n", "fitness": 0.0, "islands": [0, 1, 2, 3, 4]}
{"src": "import numpy as np\n\nclass Policy:\n    def __init__(self):\n        self.memory = {'prev_observation': None, 'prev_action': None, 'prev_reward': 0, 'prev_observation_key_picked': False, 'prev_observation_door_opened': False}\n        self.notes = []\n\n    def act(self, observation):\n        if self.memory['prev_observation'] is None:\n            self.memory['prev_observation'] = observation\n            return 2  # Move forward to explore the environment\n        else:\n            if observation['image'][3][5][0] == 5 and not self.memory['prev_observation_key_picked']:\n                self.memory['prev_observation_key_picked'] = True\n                self.memory['prev_reward'] += 0.1  # Reward for picking up the key for the first time\n            elif observation['image'][3][5][0] == 4 and observation['image'][3][5][2] == 2 and self.memory['prev_observation_key_picked']:\n                if observation['direction'] == self.memory['prev_observation']['direction']:\n                    if self.memory['prev_observation_door_opened'] == False:\n                        self.memory['prev_observation_door_opened'] = True\n                        self.memory['prev_reward'] += 0.2  # Reward for opening the door\n                    return 5  # Use key to open the door\n            elif observation['image'][3][5][0] == 7:\n                if observation['direction'] == self.memory['prev_observation']['direction']:\n                    return 3  # Pick up the box if facing it\n            elif observation['image'][3][5][1] == 1:\n                if observation['direction'] == self.memory['prev_observation']['direction']:\n                    return 2  # Move forward if the tile is empty\n            elif observation['image'][3][5][1] == 2:\n                if observation['direction'] == self.memory['prev_observation']['direction']:\n                    return 4  # Drop the box if facing an empty tile\n        return np.random.choice([0,1,2,4])  # If none of the conditions are met, explore or drop the box randomly\n\n    def update(self, observation, action, reward, next_observation):\n        self.memory['prev_observation'] = observation\n        self.memory['prev_action'] = action\n        self.memory['prev_reward'] = reward\n\n    def produce_report(self):\n        return f\"Policy performance report: Total reward = {self.memory['prev_reward']}\"\n", "fitness": 0.0, "islands": [0, 1, 2, 3, 4]}
{"src": "import numpy as np\n\nclass Policy:\n    def __init__(self):\n        self.notes = []\n\n    def act(self, observation):\n        direction = observation['direction']\n        image = observation['image']\n\n        if self.is_item_adjacent(image, 3, 5):\n            if image[3][5][0] == 5:  # Key\n                self.notes.append(\"Picked up key\")\n                return 3  # Pickup item\n            elif image[3][5][0] == 4:  # Door\n                if image[3][5][2] == 2:  # If the door is locked\n                    if self.has_key(image):\n                        self.notes.append(\"Toggled key to open the door\")\n                        return 5  # Toggle key to open door\n\n        if self.can_move_forward(image):\n            return 2  # Move forward\n        elif self.can_turn_right(image, direction):\n            return 1  # Turn right\n        else:\n            return 0  # Turn left\n\n    def update(self, observation, action, reward, next_observation):\n        # No need to update anything in this simple policy\n        pass\n\n    def is_item_adjacent(self, image, row, col):\n        adjacent_tiles = [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]\n        for r, c in adjacent_tiles:\n            if 0 <= r < 7 and 0 <= c < 7 and image[r][c][0] in [4, 5]:  # Door or Key\n                return True\n        return False\n\n    def can_move_forward(self, image):\n        return image[2][5][0] == 1  # Empty\n\n    def can_turn_right(self, image, direction):\n        if direction == 0:  # Right\n            return image[3][4][0] == 1  # Empty\n        elif direction == 1:  # Down\n            return image[4][5][0] == 1  # Empty\n        elif direction == 2:  # Left\n            return image[3][6][0] == 1  # Empty\n        else:  # Up\n            return image[2][5][0] == 1  # Empty\n\n    def has_key(self, image):\n        for i in range(7):\n            for j in range(7):\n                if image[i][j][0] == 5:  # Key\n                    return True\n        return False\n\n    def produce_report(self):\n        return \"Policy performance summary: \" + \", \".join(self.notes)\n\n# Example usage\npolicy = Policy()\nobservation = {'direction': 0, 'image': np.zeros((7, 7, 3))}\naction = policy.act(observation)\nreward = 0\nnext_observation = {'direction': 0, 'image': np.zeros((7, 7, 3))}\npolicy.update(observation, action, reward, next_observation)\nreport = policy.produce_report()\nprint(report)\n", "fitness": 0.0, "islands": [0, 1, 2, 3, 4]}
{"src": "import numpy as np\nfrom collections import defaultdict\n\nclass Policy:\n    def __init__(self):\n        self.memory = defaultdict(int)\n        self.holding = False\n        self.key_picked = False\n        self.door_opened = False\n        self.notes = []\n\n    def act(self, observation):\n        direction = observation['direction']\n        image = observation['image']\n\n        # Check if we are adjacent to the box and facing it\n        if (direction == 0 and image[3][6][0] == 7 and not self.holding) or (direction == 2 and image[3][4][0] == 7 and not self.holding):\n            return 3  # Attempt to pick up the box\n\n        # Check for the presence of the door and the key\n        if direction == 0 and image[3][6][0] == 4 and not self.door_opened:\n            if self.holding and self.key_picked:\n                return 5  # Attempt to open the door\n        elif direction == 2 and image[3][4][0] == 4 and not self.door_opened:\n            if self.holding and self.key_picked:\n                return 5  # Attempt to open the door\n\n        # If we don't have any special actions to take, move forward\n        return 2\n\n    def update(self, observation, action, reward, next_observation):\n        self.notes.append(f\"Action: {action}, Reward: {reward}\")\n\n        if action == 3:\n            self.holding = True\n            self.notes.append(\"Picked up box\")\n        elif action == 4:\n            self.holding = False\n            self.notes.append(\"Dropped box\")\n        elif action == 5:\n            self.door_opened = True\n            self.notes.append(\"Opened the door\")\n\n        # Track if the key has been picked up\n        if observation['image'][3][5][0] == 5 and not self.key_picked:\n            self.key_picked = True\n            self.notes.append(\"Picked up the key\")\n\n    def produce_report(self):\n        return \"\\n\".join(self.notes)\n", "fitness": 0.0, "islands": [0, 1, 2, 3, 4]}
{"src": "import numpy as np\n\nclass Policy:\n    def __init__(self):\n        self.memory = {}\n        self.notes = []\n\n    def act(self, observation):\n        # Explore the environment by moving around\n        action = np.random.choice([0, 1, 2])\n        return action\n\n    def update(self, observation, action, reward, next_observation):\n        # Update the memory based on the observation, action, reward, and next_observation\n        for key in observation.keys():\n            self.memory[key] = observation[key]\n        self.memory[\"action\"] = action\n        self.memory[\"reward\"] = reward\n        for key in next_observation.keys():\n            self.memory[\"next_\" + key] = next_observation[key]\n\n        self.notes.append(\"Updated memory based on observation, action, reward, and next_observation\")\n\n    def produce_report(self) -> str:\n        # Analyze the collected notes to produce a performance report\n        report = \"Policy performance summary: \\n\"\n        report += \"Total actions taken: \" + str(len(self.notes)) + \"\\n\"\n        report += \"Last reward received: \" + str(self.memory[\"reward\"]) + \"\\n\"\n\n        return report\n", "fitness": 0.0, "islands": [0, 1, 2, 3, 4]}
{"src": "import numpy as np\nimport random\n\nclass Policy:\n    def __init__(self):\n        self.memory = {}\n        self.notes = []\n\n    def act(self, observation):\n        direction = observation['direction']\n        image = observation['image']\n\n        # Check if the box is in the current view and pick it up if it is\n        if 7 in image[:,:,0]:\n            if 7 in image[3, :5, 0] and direction == 0:  # Box is to the right\n                return 3  # Pickup item\n            elif 7 in image[:3, 3, 0] and direction == 3:  # Box is above\n                return 3  # Pickup item\n            elif 7 in image[3, 2:, 0] and direction == 2:  # Box is to the left\n                return 3  # Pickup item\n            elif 7 in image[4:, 3, 0] and direction == 1:  # Box is below\n                return 3  # Pickup item\n            else:\n                return random.choice([0, 1, 2])  # Turn left, turn right, or move forward to explore\n\n        # Check if the key is in the current view and pick it up if it is\n        if 5 in image[:,:,0]:\n            if 5 in image[3, :5, 0] and direction == 0:  # Key is to the right\n                return 3  # Pickup item\n            elif 5 in image[:3, 3, 0] and direction == 3:  # Key is above\n                return 3  # Pickup item\n            elif 5 in image[3, 2:, 0] and direction == 2:  # Key is to the left\n                return 3  # Pickup item\n            elif 5 in image[4:, 3, 0] and direction == 1:  # Key is below\n                return 3  # Pickup item\n\n        # Check if the door is in the current view and open it if it is\n        if 4 in image[:,:,0]:\n            if 4 in image[3, :5, 0] and direction == 0:  # Door is to the right\n                return 5  # Toggle key to open door\n            elif 4 in image[:3, 3, 0] and direction == 3:  # Door is above\n                return 5  # Toggle key to open door\n            elif 4 in image[3, 2:, 0] and direction == 2:  # Door is to the left\n                return 5  # Toggle key to open door\n            elif 4 in image[4:, 3, 0] and direction == 1:  # Door is below\n                return 5  # Toggle key to open door\n\n        # If nothing in the current view, explore by turning left, right, or moving forward\n        return random.choice([0, 1, 2])\n\n    def update(self, observation, action, reward, next_observation):\n        self.memory[(observation, action)] = (reward, next_observation)\n        self.notes.append('Action: {}, Reward: {}'.format(action, reward))\n\n    def produce_report(self) -> str:\n        success_count = sum(1 for pair in self.memory.values() if pair[0] > 0)\n        failure_count = sum(1 for pair in self.memory.values() if pair[0] == 0)\n        return f'Successes: {success_count}, Failures: {failure_count}'\n\n", "fitness": -99.0, "islands": [0, 1, 2, 3, 4]}
