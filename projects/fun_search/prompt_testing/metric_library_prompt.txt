To test your hypothesis you must use a report function which aggregates information about 
policy rollouts in the environment to better understand policy behavior and environmental dynamics. 
You choose at most THREE report functions from among the report library or design your own.
If you choose to design your own, New report functions are of form "REPORT_NAME(observation, action, next_observation, memory: dict) -> dict.
- observation: observation at current timestep
- action: policy's action after seeing observation
- next_observation: observation of state after taking action
- memory: dict, a persistent object passed between calls to "REPORT_NAME" over a single trajectory. Can be used to store information
for report computation over multiple timesteps. Each report should include a "description" variable describing the report. 
After the final time-step of the trajectory memory["result"]: Union[float, dict[str, float]] should either contain the 
final result of the report for the trajectory or a dictionary of final results for sub-statistics
memory["description"]: str should contain a detailed description of the report. 
"REPORT_NAME" should return the memory dict.
The report across all trajectories is computed by taking the mean for each trajectory.
Note: you can extract a lot of information from observation and next_observation.
If you are reporting a ratio you should also report the numerator and denominator.

Report library:

{
  "num_trajectories": {
    "description": "Number of evaluation rollouts."
  },
  "avg_trajectory_reward": {
    "description": "Average reward across trajectories."
  },
  "avg_trajectory_length": {},
  "worst_trajectory": {
    "description": "Lowest return rollout."
  },
  "best_trajectory": {
    "description": "Highest return rollout."
  },
  "key_pickup_success": {
    "description": "Key pickup success rate"
  },
  "door_interaction_efficiency": {
    "description": "Door interaction efficiency"
  }
}